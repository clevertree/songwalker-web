# Interactive Piano Keyboard — Web Editor Plan

## Overview

Add a toggleable piano keyboard to the bottom of the web editor
(songwalker-site). The piano is **cursor-aware**: it plays the instrument
that would be active at the current Monaco cursor position. At the start of
a song (no instrument loaded), the default triangle wave plays. After a
`loadPreset()` call, the piano plays the loaded preset.

Track isolation (solo/mute) is also exposed so the user can play back
individual tracks — a critical DAW-like workflow for `.sw` editing.

## Current Web Layout

```
┌─ header ─────────────────────────────────┐
├─ toolbar: ▶ ■ | song select | btns ─────┤
├─ editor-wrapper (flex column, flex:1) ───┤
│  ┌─ editor-main (flex row, flex:1) ────┐ │
│  │  #editor-container (Monaco)  │ viz  │ │
│  │  (flex:1)                    │ panel │ │
│  │                              │ 180px │ │
│  └──────────────────────────────┴──────┘ │
│  ┌─ editor-statusbar ──────────────────┐ │
│  │ errors                    version   │ │
│  └─────────────────────────────────────┘ │
├─ about ──────────────────────────────────┤
└─ footer ─────────────────────────────────┘
```

## Proposed Layout

```
┌─ header ─────────────────────────────────┐
├─ toolbar: ▶ ■ | song | btns | ⌨ ────────┤
├─ editor-wrapper (flex column, flex:1) ───┤
│  ┌─ editor-main (flex row, flex:1) ────┐ │
│  │  #editor-container (Monaco)  │ viz  │ │
│  │  (flex:1)                    │ panel │ │
│  └──────────────────────────────┴──────┘ │
│  ┌─ piano-container (togglable) ───────┐ │
│  │ ◀ C3–B4 ▶ │ [piano keys]           │ │
│  │            │ black keys at bottom   │ │
│  └─────────────────────────────────────┘ │
│  ┌─ editor-statusbar ──────────────────┐ │
│  │ errors                    version   │ │
│  └─────────────────────────────────────┘ │
├─ about ──────────────────────────────────┤
└─ footer ─────────────────────────────────┘
```

## Plan

### 1. HTML Changes (`index.html`)

Add piano container between `.editor-main` and `.editor-statusbar`:
```html
<div class="piano-container" id="piano-container" style="display:none;">
  <div class="piano-controls">
    <button id="piano-oct-down" title="Octave Down">◀</button>
    <span id="piano-range">C3–B4</span>
    <button id="piano-oct-up" title="Octave Up">▶</button>
  </div>
  <div class="piano-keys" id="piano-keys">
    <!-- Generated by JS: 14 white keys + 10 black keys -->
  </div>
</div>
```

Add toggle button to toolbar:
```html
<button id="btn-keyboard" title="Toggle Piano Keyboard">⌨</button>
```

### 2. CSS Changes (`index.html` `<style>`)

```css
.piano-container {
    height: 80px;
    background: var(--surface);
    border-top: 1px solid var(--border);
    display: flex;
    flex-direction: row;
    align-items: stretch;
    flex-shrink: 0;
}
.piano-controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 0 8px;
    gap: 4px;
    border-right: 1px solid var(--border);
    min-width: 60px;
}
.piano-keys {
    flex: 1;
    position: relative;
    overflow: hidden;
}
.piano-key-white {
    position: absolute;
    top: 0;
    height: 100%;
    background: var(--text);
    border: 1px solid var(--border);
    border-radius: 0 0 3px 3px;
    cursor: pointer;
    z-index: 1;
}
.piano-key-white:hover { background: #e0e0e0; }
.piano-key-white.active { background: var(--accent); }

.piano-key-black {
    position: absolute;
    bottom: 0;               /* aligned to bottom per user request */
    height: 60%;
    background: var(--overlay);
    border: 1px solid var(--border);
    border-radius: 3px 3px 0 0;
    cursor: pointer;
    z-index: 2;              /* above white keys for click priority */
}
.piano-key-black:hover { background: #2a2a3a; }
.piano-key-black.active { background: var(--accent); }
```

### 3. JavaScript/TypeScript Logic (`src/main.ts`)

**Toggle:**
```ts
document.getElementById('btn-keyboard')?.addEventListener('click', () => {
    const el = document.getElementById('piano-container')!;
    el.style.display = el.style.display === 'none' ? 'flex' : 'none';
});
```

**Key generation:**
```ts
function createPianoKeys(container: HTMLElement, startNote: number, octaves: number) {
    // Generate 2 octaves of keys with data-note attributes
    // White keys: C D E F G A B × 2
    // Black keys: C# D# F# G# A# × 2
    // Position by percentage of container width
}
```

**Cursor-aware note playback:**
```ts
async function handlePianoNoteOn(midiNote: number) {
    const editor = /* Monaco editor instance */;
    const source = editor.getModel()!.getValue();
    const cursorOffset = editor.getModel()!.getOffsetAt(editor.getPosition()!);

    // 1. Get instrument at cursor (new WASM API)
    const cursorCtx = get_instrument_at_cursor(source, cursorOffset);

    // 2. Get cached presets (from last playback)
    const presetsJson = getCachedPresetsJson();

    // 3. Render single note (new WASM API)
    const samples = render_single_note(
        JSON.stringify(cursorCtx.instrument),
        midiNote, 0.8, 0.5, 44100,
        presetsJson
    );

    // 4. Play via AudioContext
    const audioBuffer = audioCtx.createBuffer(1, samples.length, 44100);
    audioBuffer.getChannelData(0).set(samples);
    const source = audioCtx.createBufferSource();
    source.buffer = audioBuffer;
    source.connect(gainNode);
    source.start();
}
```

**Keyboard shortcuts (QWERTY mapping):**
```
Z=C  S=C#  X=D  D=D#  C=E  V=F  G=F#  B=G  H=G#  N=A  J=A#  M=B
Q=C+1  2=C#+1  W=D+1  3=D#+1  E=E+1  R=F+1  5=F#+1  T=G+1  6=G#+1  Y=A+1  7=A#+1  U=B+1
```

Only active when piano is visible and Monaco doesn't have focus, OR when a
modifier key is held.

### 4. Track Isolation UI

Add a track list panel (collapsible) that shows all track names extracted via
`get_track_names()` after compilation. Each track has solo (S) and mute (M)
buttons matching the VSTi slot rack style.

When the user clicks Play with tracks soloed/muted, use
`render_song_samples_filtered()` instead of `render_song_samples_with_presets()`.

```html
<div class="track-list" id="track-list">
  <!-- Generated after compile: -->
  <div class="track-item">
    <span class="track-name">melody</span>
    <button class="track-solo">S</button>
    <button class="track-mute">M</button>
  </div>
</div>
```

**Placement:** Inside the viz-panel or as a new section below the toolbar.

### 5. Preset Caching for Piano

The piano needs decoded preset data to render notes that use sampler instruments.
The `PresetLoader` already caches loaded presets. After each song playback:
1. Serialize the loaded presets to JSON (same format as `presetsJson` passed to
   `render_song_samples_with_presets`)
2. Store in a module-level variable
3. Reuse when the piano triggers `render_single_note()`

If presets aren't loaded yet (user hasn't played the song), the piano falls back
to the default triangle wave — `render_single_note()` with a default
`InstrumentConfig` and empty presets.

## Streaming Playback (Future)

The core plan introduces a **streaming execution model** with a `SongRunner`
and `EventBuffer` (see `songwalker-core/docs/cursor_aware_plan.md`,
Architectural Decision #2). This enables:

- **Infinite songs:** `while`/`for` loops that never end
- **Play from cursor:** `start_playback_from_cursor()` seeks silently, then streams
- **Pre-buffer instrument awareness:** instruments peek ahead for legato/portamento

The piano keyboard does **not** require streaming — it uses `render_single_note()`
and `cursor_context()`, which work with the existing compiler for finite queries.

When streaming playback is available, the Play button will switch from
`render_song_samples()` (full offline render) to the incremental SongRunner+
EventBuffer model, enabling playback of infinite songs and lower startup latency.

## Depends On

- **songwalker-core** cursor-aware APIs (see `songwalker-core/docs/cursor_aware_plan.md`):
  - `get_instrument_at_cursor()` — determines which instrument plays at cursor
  - `render_single_note()` — renders one note to audio samples
  - `get_track_names()` — lists tracks for solo/mute UI
  - `render_song_samples_filtered()` — renders with track isolation

- **songwalker-js** must re-export the new WASM functions (see
  `songwalker-js/docs/piano_keyboard_plan.md`)

## Outstanding Questions

1. **Piano focus vs editor focus:** When the user is typing in Monaco, QWERTY
   shortcuts would interfere. Should piano keyboard shortcuts only work when:
   - (a) Piano container has focus (user clicked on it)?
   - (b) A modifier key is held (e.g., Alt+Z plays C)?
   - (c) Monaco is blurred / not focused?

2. **Latency:** `render_single_note()` does a full WASM render for each keypress.
   For simple oscillators this is fast (~1ms). For sampler presets with large zones,
   it could be slower. Should we:
   - (a) Pre-render a short buffer and play immediately (current plan)?
   - (b) Use WebAudio `OscillatorNode` for oscillator types (instant) and only use
     WASM for sampler presets?
   - (c) Stream via AudioWorklet for lowest latency?

3. **Note duration:** The piano renders a fixed-length note (0.5s gate + release
   tail). Should the gate instead last as long as the mouse/key is held? This would
   require streaming audio or a note-off mechanism.

4. **Mobile support:** Should piano keys respond to touch events? (Probably yes,
   for tablet use.)

5. **Cursor tracking during playback:** If the song is playing and the note
   highlighter is moving the cursor, should the piano's instrument change in real
   time to match? This would be a nice polish but adds complexity.

## File Impact

| File | Changes |
|------|---------|
| `index.html` | Piano container HTML, CSS, toggle button in toolbar |
| `src/main.ts` | Piano key generation, event handlers, WASM calls, keyboard shortcuts, track isolation UI |
